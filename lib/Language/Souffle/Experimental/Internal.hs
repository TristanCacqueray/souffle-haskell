
{-# LANGUAGE TypeFamilies, TypeOperators, DataKinds, UndecidableInstances #-}
{-# LANGUAGE FlexibleContexts, FlexibleInstances, TypeApplications, PolyKinds #-}
{-# LANGUAGE MultiParamTypeClasses, GADTs, ScopedTypeVariables #-}

module Language.Souffle.Experimental.Internal
  ( TypeInfo(..)
  , Structure
  , NameFor
  , nameFor
  , GetNames
  , AccessorNames
  , accessorNames
  , MapType
  , TupleOf
  , Tuple
  , ToTerms(..)
  ) where

import Language.Souffle.Experimental.Types
import GHC.Generics
import GHC.TypeLits
import Data.Kind
import Data.Proxy
import Data.Char ( toLower )
import Data.List.NonEmpty ( NonEmpty(..) )


data TypeInfo (a :: k) (ts :: [Type])
  = TypeInfo

type family a ++ b = c where
  '[] ++ b = b
  a ++ '[] = a
  (a ': b) ++ c = a ': (b ++ c)

type family Structure a :: [Type] where
  Structure a = Collect (Rep a)

type family Collect (a :: Type -> Type) where
  Collect (a :*: b) = Collect a ++ Collect b
  Collect (M1 _ _ a) = Collect a
  Collect (K1 _ ty) = '[ty]


nameFor :: forall a. (KnownSymbol (NameFor a)) => Proxy a -> String
nameFor _ = formatName $ symbolVal (Proxy @(NameFor a)) where
  formatName = fmap toLower -- TODO camelcase to snake case?

type family NameFor a where
  NameFor a = GetName (Rep a)

type family GetName (repr :: Type -> Type) :: Symbol where
  GetName (D1 ('MetaData name _ _ _) _) = name

type family AccessorNames a :: [Symbol] where
  AccessorNames a = GetAccessorNames (Rep a)

type family GetAccessorNames (f :: Type -> Type) :: [Symbol] where
  GetAccessorNames (a :*: b) = GetAccessorNames a ++ GetAccessorNames b
  GetAccessorNames (C1 ('MetaCons _ _ 'False) _) = '[]
  GetAccessorNames (S1 ('MetaSel ('Just name) _ _ _) a) = '[name] ++ GetAccessorNames a
  GetAccessorNames (M1 _ _ a) = GetAccessorNames a
  GetAccessorNames (K1 _ _) = '[]

-- TODO: think of better name
class GetNames (symbols :: [Symbol]) where
  getNames :: Proxy symbols -> [String]

instance GetNames '[] where
  getNames = const []

instance (KnownSymbol s, GetNames symbols) => GetNames (s ': symbols) where
  getNames _ =
    let sym = symbolVal (Proxy :: Proxy s)
        symbols =  getNames (Proxy :: Proxy symbols)
     in sym : symbols

accessorNames :: forall a. GetNames (AccessorNames a) => Proxy a -> Maybe [String]
accessorNames _ = case getNames (Proxy :: Proxy (AccessorNames a)) of
  [] -> Nothing
  names -> Just names

type family MapType (f :: Type -> Type) (ts :: [Type]) :: [Type] where
  MapType _ '[] = '[]
  MapType f (t ': ts) = f t ': MapType f ts

type Tuple ctx ts = TupleOf (MapType (Term ctx) ts)

type family TupleOf (ts :: [Type]) = t where
  TupleOf '[t] = t
  TupleOf '[t1, t2] = (t1, t2)
  TupleOf '[t1, t2, t3] = (t1, t2, t3)
  TupleOf '[t1, t2, t3, t4] = (t1, t2, t3, t4)
  TupleOf '[t1, t2, t3, t4, t5] = (t1, t2, t3, t4, t5)
  TupleOf '[t1, t2, t3, t4, t5, t6] = (t1, t2, t3, t4, t5, t6)
  TupleOf '[t1, t2, t3, t4, t5, t6, t7] = (t1, t2, t3, t4, t5, t6, t7)
  TupleOf '[t1, t2, t3, t4, t5, t6, t7, t8] = (t1, t2, t3, t4, t5, t6, t7, t8)
  TupleOf '[t1, t2, t3, t4, t5, t6, t7, t8, t9] = (t1, t2, t3, t4, t5, t6, t7, t8, t9)
  TupleOf '[t1, t2, t3, t4, t5, t6, t7, t8, t9, t10] = (t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)
  -- NOTE: Only facts with up to 10 arguments are currently supported.

class ToTerms (ts :: [Type]) where
  toTerms :: Proxy ctx -> TypeInfo a ts -> Tuple ctx ts -> NonEmpty SimpleTerm

instance ToTerms '[t] where
  toTerms _ _ a =
    toTerm a :| []

instance ToTerms '[t1, t2] where
  toTerms _ _ (a, b) =
    toTerm a :| [toTerm b]

instance ToTerms '[t1, t2, t3] where
  toTerms _ _ (a, b, c) =
    toTerm a :| [toTerm b, toTerm c]

instance ToTerms '[t1, t2, t3, t4] where
  toTerms _ _ (a, b, c, d) =
    toTerm a :| [toTerm b, toTerm c, toTerm d]

instance ToTerms '[t1, t2, t3, t4, t5] where
  toTerms _ _ (a, b, c, d, e) =
    toTerm a :| [toTerm b, toTerm c, toTerm d, toTerm e]

instance ToTerms '[t1, t2, t3, t4, t5, t6] where
  toTerms _ _ (a, b, c, d, e, f) =
    toTerm a :| [toTerm b, toTerm c, toTerm d, toTerm e, toTerm f]

instance ToTerms '[t1, t2, t3, t4, t5, t6, t7] where
  toTerms _ _ (a, b, c, d, e, f, g) =
    toTerm a :| [toTerm b, toTerm c, toTerm d, toTerm e, toTerm f, toTerm g]

instance ToTerms '[t1, t2, t3, t4, t5, t6, t7, t8] where
  toTerms _ _ (a, b, c, d, e, f, g, h) =
    toTerm a :| [toTerm b, toTerm c, toTerm d, toTerm e, toTerm f, toTerm g, toTerm h]

instance ToTerms '[t1, t2, t3, t4, t5, t6, t7, t8, t9] where
  toTerms _ _ (a, b, c, d, e, f, g, h, i) =
    toTerm a :| [toTerm b, toTerm c, toTerm d, toTerm e, toTerm f, toTerm g, toTerm h, toTerm i]

instance ToTerms '[t1, t2, t3, t4, t5, t6, t7, t8, t9, t10] where
  toTerms _ _ (a, b, c, d, e, f, g, h, i, j) =
    toTerm a :| [ toTerm b, toTerm c, toTerm d, toTerm e, toTerm f
                , toTerm g, toTerm h, toTerm i, toTerm j ]
-- NOTE: Only facts with up to 10 arguments are currently supported.

toTerm :: Term ctx t -> SimpleTerm
toTerm = \case
  Var v -> V v
  Str s -> S s
  Int x -> I x

